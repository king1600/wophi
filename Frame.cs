using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace Wophi {

  public enum WebsockOpCode {
    Continue = 0x00,
    Text     = 0x01,
    Binary   = 0x02,
    Close    = 0x08,
    Ping     = 0x09,
    Pong     = 0x0a
  }

  public struct WebsockFrame {
    public bool Fin;
    public bool Rsv1;
    public bool Rsv2;
    public bool Rsv3;
    public bool Masked;
    public byte[] Data;
    public byte[] MaskingKey;
    public WebsockOpCode Opcode;

    // random device for generating random bytes
    public static readonly Random Rand = new Random();

    // calculate the byte size of a frame for allocation
    private static UInt64 GetFrameSize(ref WebsockFrame frame) {
      UInt64 size = (UInt64)(2 + (frame.Masked ? 4 : 0) + frame.Data.Length);
      if (frame.Data.Length >= 126 && frame.Data.Length < 63336) size += 2;
      else if (frame.Data.Length >= 65536) size += 8;
      return size;
    }

     // Dump Websocket frame into byte array data
    public byte[] Dump() {
      UInt64 offset = 0;                                // output data tracking 
      byte[] output = new byte[GetFrameSize(ref this)]; // output data

      // write first byte in header
      output[offset] = (byte)(Fin ? 0x80 : 0);   // set fin bit (1st)
      output[offset] |= (byte)(Rsv1 ? 0x40 : 0); // set rsv1 bit (2nd)
      output[offset] |= (byte)(Rsv2 ? 0x20 : 0); // set rsv2 bit (3rd)
      output[offset] |= (byte)(Rsv3 ? 0x10 : 0); // set rsv3 bit (4th)
      output[offset] |= (byte)(Opcode);          // set opcode bits (5th - 8th)
      offset++;                                  // move to next byte

      // get frame masked bit value
      byte masked = (byte)(Masked ? 0x80 : 0);

      // payload is 7 bits, write length as is
      if (Data.Length <= 125) {
        output[offset++] = (byte)(masked | Data.Length);

      // payload is 16 bits, distribute bytes
      } else if (Data.Length >= 126 && Data.Length < 65536) {
        output[offset++] = (byte)(masked | 126);
        output[offset++] = (byte)((Data.Length >> 8) & 0xff);
        output[offset++] = (byte)((Data.Length >> 0) & 0xff);

      // payload is 64 bits, distribute bytes
      } else {
        output[offset++] = (byte)(masked | 127);
        output[offset++] = (byte)((Data.Length >> 56) & 0xff);
        output[offset++] = (byte)((Data.Length >> 48) & 0xff);
        output[offset++] = (byte)((Data.Length >> 40) & 0xff);
        output[offset++] = (byte)((Data.Length >> 32) & 0xff);
        output[offset++] = (byte)((Data.Length >> 24) & 0xff);
        output[offset++] = (byte)((Data.Length >> 16) & 0xff);
        output[offset++] = (byte)((Data.Length >> 8) & 0xff);
        output[offset++] = (byte)((Data.Length >> 0) & 0xff);
      }

      // generate mask if frame is masked
      MaskingKey = null;
      if (Masked) {
        MaskingKey = new byte[4];
        Rand.NextBytes(MaskingKey);
        for (int i = 0; i < MaskingKey.Length; i++)
          output[offset++] = MaskingKey[i];
      }

      // add payload data
      for (int i = 0; i < Data.Length; i++)
        output[offset++] = (byte)(Masked ? // check if payload is masked
          Data[i] ^ MaskingKey[i % 4]            // payload is masked
          : Data[i]);                      // payload is not masked

      // return generated byte data
      return output;
    }
  }
}